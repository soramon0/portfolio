// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: projects.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountPublishedProjects = `-- name: CountPublishedProjects :one
SELECT count(*) FROM projects
WHERE published_at IS NOT NULL
`

func (q *Queries) CountPublishedProjects(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountPublishedProjects)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetPublishedProjectBySlug = `-- name: GetPublishedProjectBySlug :one
SELECT
  p.id,
  p.client_name,
  p.name,
  p.slug,
  p.subtitle,
  p.description,
  p.live_link,
  p.code_link,
  p.start_date,
  p.technologies,
  p.credits,
  p.end_date,
  p.launch_date,
  p.created_at,
  p.updated_at,
  f.name AS cover_image_name,
  f.url AS cover_image_url,
  f.alt AS cover_image_alt,
  ARRAY_REMOVE(ARRAY_AGG(categories.name), NULL) AS categories,
  COALESCE(
    (
      SELECT 
        JSON_AGG(
          JSON_BUILD_OBJECT(
            'id', f.id,
            'url', f.url,
            'alt', f.alt,
            'name', f.name,
            'uploaded_at', f.uploaded_at,
            'type', f.type
          ) 
          ORDER BY f.id
        )
      FROM files AS f WHERE f.project_id = p.id
    )::json,
    '[]'::json
  ) AS gallery
FROM
  projects AS p
LEFT JOIN
  files as f ON f.id = p.cover_image_id
LEFT JOIN
  projects_categories ON p.id = projects_categories.project_id
LEFT JOIN
  categories ON categories.id = projects_categories.category_id
WHERE
  p.published_at IS NOT NULL AND slug = $1
GROUP BY
  p.id, f.name, f.url, f.alt
`

type GetPublishedProjectBySlugRow struct {
	ID             pgtype.UUID        `json:"id"`
	ClientName     string             `json:"client_name"`
	Name           string             `json:"name"`
	Slug           string             `json:"slug"`
	Subtitle       string             `json:"subtitle"`
	Description    string             `json:"description"`
	LiveLink       pgtype.Text        `json:"live_link,omitempty"`
	CodeLink       pgtype.Text        `json:"code_link"`
	StartDate      pgtype.Date        `json:"start_date"`
	Technologies   []string           `json:"technologies"`
	Credits        []string           `json:"credits"`
	EndDate        pgtype.Date        `json:"end_date"`
	LaunchDate     pgtype.Date        `json:"launch_date"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	CoverImageName pgtype.Text        `json:"cover_image_name"`
	CoverImageUrl  pgtype.Text        `json:"cover_image_url"`
	CoverImageAlt  pgtype.Text        `json:"cover_image_alt"`
	Categories     interface{}        `json:"categories"`
	Gallery        interface{}        `json:"gallery"`
}

func (q *Queries) GetPublishedProjectBySlug(ctx context.Context, slug string) (GetPublishedProjectBySlugRow, error) {
	row := q.db.QueryRow(ctx, GetPublishedProjectBySlug, slug)
	var i GetPublishedProjectBySlugRow
	err := row.Scan(
		&i.ID,
		&i.ClientName,
		&i.Name,
		&i.Slug,
		&i.Subtitle,
		&i.Description,
		&i.LiveLink,
		&i.CodeLink,
		&i.StartDate,
		&i.Technologies,
		&i.Credits,
		&i.EndDate,
		&i.LaunchDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CoverImageName,
		&i.CoverImageUrl,
		&i.CoverImageAlt,
		&i.Categories,
		&i.Gallery,
	)
	return i, err
}

const ListPublishedProjects = `-- name: ListPublishedProjects :many
SELECT
  p.id,
  p.client_name,
  p.name,
  p.slug,
  p.subtitle,
  p.start_date,
  f.name as cover_image_name,
  f.url as cover_image_url,
  f.alt as cover_image_alt
FROM
  projects AS p
LEFT JOIN
  files as f
ON
  f.id = p.cover_image_id
WHERE
  p.published_at IS NOT NULL
ORDER BY
  p.id, p.created_at
LIMIT $1 OFFSET $2
`

type ListPublishedProjectsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPublishedProjectsRow struct {
	ID             pgtype.UUID `json:"id"`
	ClientName     string      `json:"client_name"`
	Name           string      `json:"name"`
	Slug           string      `json:"slug"`
	Subtitle       string      `json:"subtitle"`
	StartDate      pgtype.Date `json:"start_date"`
	CoverImageName pgtype.Text `json:"cover_image_name"`
	CoverImageUrl  pgtype.Text `json:"cover_image_url"`
	CoverImageAlt  pgtype.Text `json:"cover_image_alt"`
}

func (q *Queries) ListPublishedProjects(ctx context.Context, arg ListPublishedProjectsParams) ([]ListPublishedProjectsRow, error) {
	rows, err := q.db.Query(ctx, ListPublishedProjects, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublishedProjectsRow{}
	for rows.Next() {
		var i ListPublishedProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientName,
			&i.Name,
			&i.Slug,
			&i.Subtitle,
			&i.StartDate,
			&i.CoverImageName,
			&i.CoverImageUrl,
			&i.CoverImageAlt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
