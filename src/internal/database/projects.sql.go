// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: projects.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	null "gopkg.in/guregu/null.v4"
)

const CountPublishedProjects = `-- name: CountPublishedProjects :one
SELECT count(*) FROM projects
WHERE published_at IS NOT NULL
`

func (q *Queries) CountPublishedProjects(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountPublishedProjects)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetPublishedProjectBySlug = `-- name: GetPublishedProjectBySlug :one
SELECT
  p.id,
  p.client_name,
  p.name,
  p.slug,
  p.subtitle,
  p.description,
  p.live_link,
  p.code_link,
  p.start_date,
  p.technologies,
  p.end_date,
  p.launch_date,
  p.created_at,
  p.updated_at,
  f.name as cover_image_name,
  f.url as cover_image_url,
  f.alt as cover_image_alt,
  COALESCE(
    (
      SELECT 
        JSON_AGG(
          JSON_BUILD_OBJECT(
            'id', f.id,
            'url', f.url,
            'alt', f.alt,
            'name', f.name,
            'uploaded_at', f.uploaded_at,
            'type', f.type
          ) 
          ORDER BY f.id
        )
      FROM files AS f WHERE f.project_id = p.id
    )::json,
    '[]'::json
  ) AS gallery
FROM
  projects AS p
LEFT JOIN
  files as f
ON
  f.id = p.cover_image_id
WHERE
  p.published_at IS NOT NULL AND slug = $1
`

type GetPublishedProjectBySlugRow struct {
	ID             uuid.UUID   `json:"id"`
	ClientName     string      `json:"client_name"`
	Name           string      `json:"name"`
	Slug           string      `json:"slug"`
	Subtitle       string      `json:"subtitle"`
	Description    string      `json:"description"`
	LiveLink       null.String `json:"live_link,omitempty"`
	CodeLink       null.String `json:"code_link"`
	StartDate      time.Time   `json:"start_date"`
	Technologies   []string    `json:"technologies"`
	EndDate        null.Time   `json:"end_date"`
	LaunchDate     null.Time   `json:"launch_date"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
	CoverImageName null.String `json:"cover_image_name"`
	CoverImageUrl  null.String `json:"cover_image_url"`
	CoverImageAlt  null.String `json:"cover_image_alt"`
	Gallery        interface{} `json:"gallery"`
}

func (q *Queries) GetPublishedProjectBySlug(ctx context.Context, slug string) (GetPublishedProjectBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, GetPublishedProjectBySlug, slug)
	var i GetPublishedProjectBySlugRow
	err := row.Scan(
		&i.ID,
		&i.ClientName,
		&i.Name,
		&i.Slug,
		&i.Subtitle,
		&i.Description,
		&i.LiveLink,
		&i.CodeLink,
		&i.StartDate,
		pq.Array(&i.Technologies),
		&i.EndDate,
		&i.LaunchDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CoverImageName,
		&i.CoverImageUrl,
		&i.CoverImageAlt,
		&i.Gallery,
	)
	return i, err
}

const ListPublishedProjects = `-- name: ListPublishedProjects :many
SELECT
  p.id,
  p.client_name,
  p.name,
  p.slug,
  p.subtitle,
  p.start_date,
  f.name as cover_image_name,
  f.url as cover_image_url,
  f.alt as cover_image_alt
FROM
  projects AS p
LEFT JOIN
  files as f
ON
  f.id = p.cover_image_id
WHERE
  p.published_at IS NOT NULL
ORDER BY
  p.id, p.created_at
LIMIT $1 OFFSET $2
`

type ListPublishedProjectsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPublishedProjectsRow struct {
	ID             uuid.UUID   `json:"id"`
	ClientName     string      `json:"client_name"`
	Name           string      `json:"name"`
	Slug           string      `json:"slug"`
	Subtitle       string      `json:"subtitle"`
	StartDate      time.Time   `json:"start_date"`
	CoverImageName null.String `json:"cover_image_name"`
	CoverImageUrl  null.String `json:"cover_image_url"`
	CoverImageAlt  null.String `json:"cover_image_alt"`
}

func (q *Queries) ListPublishedProjects(ctx context.Context, arg ListPublishedProjectsParams) ([]ListPublishedProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, ListPublishedProjects, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublishedProjectsRow{}
	for rows.Next() {
		var i ListPublishedProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientName,
			&i.Name,
			&i.Slug,
			&i.Subtitle,
			&i.StartDate,
			&i.CoverImageName,
			&i.CoverImageUrl,
			&i.CoverImageAlt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
