// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: projects.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	null "gopkg.in/guregu/null.v4"
)

const ListPublishedProjects = `-- name: ListPublishedProjects :many
SELECT
  p.id,
  p.client_name,
  p.name,
  p.description,
  p.live_link,
  p.code_link,
  p.start_date,
  p.end_date,
  p.created_at,
  p.updated_at,
  f.name as cover_image_name,
  f.url as cover_image_url,
  f.alt as cover_image_alt,
  COALESCE(
    (
      SELECT 
        JSON_AGG(
          JSON_BUILD_OBJECT(
            'id', f.id,
            'url', f.url,
            'alt', f.alt,
            'name', f.name,
            'uploaded_at', f.uploaded_at,
            'type', f.type
          ) 
          ORDER BY f.id
        )
      FROM files AS f WHERE f.project_id = p.id
    )::json,
    '[]'::json
  ) AS gallery
FROM
  projects AS p
LEFT JOIN
  files as f
ON
  f.id = p.cover_image_id
WHERE
  p.published_at IS NOT NULL
ORDER BY
  p.id, p.created_at
LIMIT $1 OFFSET $2
`

type ListPublishedProjectsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPublishedProjectsRow struct {
	ID             uuid.UUID   `json:"id"`
	ClientName     string      `json:"client_name"`
	Name           string      `json:"name"`
	Description    string      `json:"description"`
	LiveLink       null.String `json:"live_link,omitempty"`
	CodeLink       null.String `json:"code_link"`
	StartDate      time.Time   `json:"start_date"`
	EndDate        null.Time   `json:"end_date"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
	CoverImageName null.String `json:"cover_image_name"`
	CoverImageUrl  null.String `json:"cover_image_url"`
	CoverImageAlt  null.String `json:"cover_image_alt"`
	Gallery        interface{} `json:"gallery"`
}

func (q *Queries) ListPublishedProjects(ctx context.Context, arg ListPublishedProjectsParams) ([]ListPublishedProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, ListPublishedProjects, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublishedProjectsRow{}
	for rows.Next() {
		var i ListPublishedProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientName,
			&i.Name,
			&i.Description,
			&i.LiveLink,
			&i.CodeLink,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CoverImageName,
			&i.CoverImageUrl,
			&i.CoverImageAlt,
			&i.Gallery,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
